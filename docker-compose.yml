networks:
  frontend:
    name: frontend
  backend:
    name: backend

services:
  #  authelia:
  #    build:
  #      context: ./authelia
  #    container_name: authelia
  #    restart: unless-stopped
  #    ports:
  #      - "9091:9091"
  #    volumes:
  #      - ${CONFIG_PATH}authelia:/config
  #    environment:
  #      - "TZ=${TIMEZONE}"
  #      - "REDIS_PASSWORD=${REDIS_PASSWORD}"
  #    depends_on:
  #      - redis
  #    networks:
  #      - frontend
  #      - backend
  #
  #  traefik:
  #    container_name: traefik
  #    image: traefik:3.5.3
  #    restart: always
  #    environment:
  #      - TZ=${TIMEZONE}
  #      - DOMAIN=${SITE_ADDRESS}
  #    ports:
  ##        - "80:80"
  ##        - "443:443"
  ##        - "8080:8080"
  #      - "8082:8082"
  ##      - "3306:3306"
  ##      - "5432:5432"
  ##      - "6379:6379"
  #    volumes:
  #      - /etc/localtime:/etc/localtime:ro
  #      - /var/run/docker.sock:/var/run/docker.sock:ro
  #      - ${CONFIG_PATH}traefik/config:/config
  #      - ${CONFIG_PATH}traefik/traefik.yml:/etc/traefik/traefik.yml
  #      - ${LOG_PATH}traefik:/traefik/logs
  #    networks:
  #      - frontend
  ##    depends_on: ['errorPage','authelia']
  #    depends_on: ['errorPage']

  certbot:
    build:
      context: ./certbot
      dockerfile: Dockerfile
    container_name: certbot
    environment:
      - DNS_PROVIDER=${CERTBOT_DNS_PROVIDER:-aliyun} # DNS 提供商: cloudflare 或 aliyun
      - DOMAIN=${DOMAIN:-haoxiaoguai.xyz} # 主域名
      - EMAIL=${CERTBOT_EMAIL:-admin@haoxiaoguai.xyz} # 证书通知邮箱
      - RENEW_INTERVAL=${CERTBOT_RENEW_INTERVAL:-43200} # 续签检查间隔(秒)
      - TZ=Asia/Shanghai
    volumes:
      - ${CONFIG_PATH}certbot/conf:/etc/letsencrypt
      - ${DATA_PATH}certbot/logs:/var/log/letsencrypt
      - ${CONFIG_PATH}certbot/conf/aliyun.ini:/etc/letsencrypt/aliyun.ini:ro
    #      - ${CONFIG_PATH}certbot/conf/cloudflare.ini:/etc/letsencrypt/cloudflare.ini:ro
    restart: unless-stopped
    networks:
      - frontend
      - backend
    labels:
      - "com.centurylinklabs.watchtower.enable=true"

  nginx:
    build:
      context: ./nginx
      args:
        - NGINX_VERSION=${NGINX_VERSION}
        - CHANGE_SOURCE=${CHANGE_SOURCE}
        - PHP_UPSTREAM_CONTAINER=${NGINX_PHP_UPSTREAM_CONTAINER}
        - PHP_UPSTREAM_PORT=${NGINX_PHP_UPSTREAM_PORT}
    container_name: nginx
    restart: always
    volumes:
      - ${APP_CODE_PATH}:${APP_CODE_PATH_CONTAINER}${APP_CODE_CONTAINER_FLAG}
      - ${NGINX_HOST_LOG_PATH}:/var/log/nginx
      - ${NGINX_SITES_PATH}:/etc/nginx/sites-available
      - ${CONFIG_PATH}nginx/nginx.conf:/etc/nginx/nginx.conf
      - ${CONFIG_PATH}nginx/snippets/:/etc/nginx/snippets/
      - ${CONFIG_PATH}certbot/conf:/etc/nginx/ssl
    ports:
      - "${NGINX_HOST_HTTP_PORT}:80"
      - "${NGINX_HOST_HTTPS_PORT}:443"
      - "${NGINX_HOST_WSS_PORT}:8080"
      - "45432:45432" # PostgresSQL 代理
      - "46379:46379" # Redis 代理
    depends_on:
      certbot:
        condition: service_started
      error-pages:
        condition: service_started
      php-fpm:
        condition: service_healthy
      minio:
        condition: service_healthy
      meilisearch:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
      pgbouncer:
        condition: service_healthy
      postgres:
        condition: service_healthy
    networks:
      - frontend
      - backend

  php-fpm:
    build:
      context: ./php-fpm
      dockerfile: Dockerfile
      args:
        - CHANGE_SOURCE=${CHANGE_SOURCE}
        - WWWUSER=${WWWUSER:-33}
        - WWWGROUP=${WWWGROUP:-33}
    container_name: php-fpm
    restart: always
    user: "${WWWUSER:-33}:${WWWGROUP:-33}" # 使用环境变量或默认值
    volumes:
      - ${APP_CODE_PATH}:${APP_CODE_PATH_CONTAINER}${APP_CODE_CONTAINER_FLAG}
      - ${CONFIG_PATH}ssh:/home/www-data/.ssh:ro
    environment:
      - APP_PATH=${APP_PATH}
    extra_hosts:
      - "host.docker.internal:host-gateway"
    networks:
      - backend
      - frontend
    depends_on:
      - redis
      - pgbouncer
      - postgres
      - minio
      - meilisearch
      - rabbitmq

  php-franken:
    build:
      context: ./php-franken
    container_name: php-franken
    restart: always
    ports:
      - "8001:8001"
      - "2019:2019"
    volumes:
      - ${APP_CODE_PATH}:${APP_CODE_PATH_CONTAINER}${APP_CODE_CONTAINER_FLAG}
      - ${CONFIG_PATH}ssh:/home/www-data/.ssh:ro
    environment:
      - APP_PATH=${APP_PATH}
      - APP_ENV=docker
      - APP_DEBUG=false
      - WATCH=true
    extra_hosts:
      - "host.docker.internal:host-gateway"
    networks:
      - backend
      - frontend

  postgres:
    build:
      context: ./postgres
      args:
        - POSTGRES_VERSION=${POSTGRES_VERSION}
    container_name: postgres
    restart: always
    volumes:
      - ${DATA_PATH}postgres:/var/lib/postgresql/data
      - ${CONFIG_PATH}postgres/docker-entrypoint-initdb.d:/docker-entrypoint-initdb.d
    ports:
      - "${POSTGRES_PORT}:5432"
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    networks:
      - backend
      - frontend

  #  postgis:
  #    image: postgis/postgis:17-3.5-alpine # 推荐指定具体版本（PostgreSQL 17 + PostGIS 3.5）
  #    platform: linux/amd64 # 兼容 Apple M 芯片（arm64），amd64 架构通用
  #    container_name: postgis
  #    restart: always
  #    environment:
  #      POSTGRES_USER: ${POSTGRES_USER}
  #      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
  #      POSTGRES_DB: ${POSTGRES_DB}
  #      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --lc-collate=C --lc-ctype=C" # 初始化编码设置
  #    ports:
  #      - "15432:5432"
  #    volumes:
  #      - ${DATA_PATH}postgis:/var/lib/postgresql/data
  #      - ${CONFIG_PATH}postgis/docker-entrypoint-initdb.d:/docker-entrypoint-initdb.d
  #    #      - ${CONFIG_PATH}postgis/postgresql.conf:/var/lib/postgresql/data/postgresql.conf
  #    #      - ${CONFIG_PATH}postgis/pg_hba.conf:/var/lib/postgresql/data/pg_hba.conf
  #    healthcheck:
  #      test: ["CMD-SHELL", "pg_isready -U postgres -d ${POSTGRES_DB}"]
  #      interval: 10s
  #      timeout: 5s
  #      retries: 5
  #    networks:
  #      - backend
  #      - frontend

  pgbouncer:
    build:
      context: ./pgbouncer
      args:
        - CHANGE_SOURCE=${CHANGE_SOURCE}
    container_name: pgbouncer
    restart: always
    environment:
      - TZ=${TIMEZONE}
      - POSTGRESQL_PASSWORD=${POSTGRES_PASSWORD}
    ports:
      - "6432:6432"
    depends_on:
      - postgres
    networks:
      - backend

  redis:
    container_name: redis
    build:
      context: ./redis
      args:
        - REDIS_VERSION=${REDIS_VERSION}
    volumes:
      - ${DATA_PATH}redis:/data
    restart: always
    command: --requirepass ${REDIS_PASSWORD}
    ports:
      - "${REDIS_PORT:-6379}:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      retries: 3
      timeout: 5s
    networks:
      - backend
      - frontend

  #  plane-redis:
  #    image: valkey/valkey:7.2.11-alpine
  #    restart: unless-stopped
  #    volumes:
  #      - redisdata:/data
  #    ports:
  #      - "6379:6379"
  #    networks:
  #      - backend
  #      - frontend

  meilisearch:
    container_name: meilisearch
    image: "getmeili/meilisearch:v1.18.0"
    restart: always
    environment:
      - MEILI_MASTER_KEY=${MEILI_MASTER_KEY}
    ports:
      - "${SEARCH_PORT:-7700}:7700"
    volumes:
      - "${DATA_PATH}/meili_data:/meili_data"
    networks:
      - frontend
      - backend
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--spider",
          "http://127.0.0.1:7700/health",
        ]
      retries: 5
      timeout: 10s
      interval: 30s
      start_period: 60s

  rabbitmq:
    build:
      context: ./rabbitmq
      dockerfile: Dockerfile
    container_name: rabbitmq
    restart: always
    ports:
      - "${RABBITMQ_PORT:-5672}:5672"
      - "${RABBITMQ_DASHBOARD_PORT:-15672}:15672"
    environment:
      - RABBITMQ_DEFAULT_USER=${RABBITMQ_DEFAULT_USER}
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_DEFAULT_PASS}
      - RABBITMQ_DEFAULT_VHOST=${RABBITMQ_DEFAULT_VHOST:-app-host}
    volumes:
      - ${DATA_PATH}rabbitmq:/var/lib/rabbitmq
      #      - ${CONFIG_PATH}rabbitmq/config:/etc/rabbitmq
      - ${LOG_PATH}rabbitmq:/var/log/rabbitmq
    networks:
      - backend

  minio:
    build:
      context: ./minio
    container_name: minio
    restart: always
    environment:
      - MINIO_ROOT_USER=${MINIO_ROOT_USER}
      - MINIO_ROOT_PASSWORD=${MINIO_ROOT_PASSWORD}
    volumes:
      - "${DATA_PATH}/minio:/data"
    ports:
      - "${MINIO_PORT_UI}:9001"
      - "${MINIO_PORT}:9000"
    networks:
      - backend

#  portainer:
#    container_name: portainer
#    build:
#      context: ./portainer
#      dockerfile: Dockerfile
#    restart: unless-stopped
#    ports:
#      # HTTPS端口（推荐优先使用）
#      - "9443:9443"
#      # HTTP端口（建议生产环境关闭或仅内网访问）
#      - "8100:9000" # HTTP端口
#      # 代理端口（用于Portainer Agent通信，集群部署必填）
#      - "9100:8000"
#    volumes:
#      - /var/run/docker.sock:/var/run/docker.sock:ro
#      - ${DATA_PATH}portainer_data:/data
#      - ./portainer/secrets:/run/secrets:ro
#    environment:
#      - TZ=Asia/Shanghai
#      - PORTAINER_ADMIN_PASSWORD=${PORTAINER_ADMIN_PASSWORD:-ChangeMe123!}
#    networks:
#      - frontend
#      - backend
#    depends_on:
#      - watchtower
#    labels:
#      - "com.centurylinklabs.watchtower.enable=true"

  #  agent:
  #    container_name: portainer_agent
  #    image: portainer/agent:2.35.0-alpine
  #    ports:
  #      - "9301:9001"
  #    restart: always
  #    volumes:
  #      - /var/run/docker.sock:/var/run/docker.sock
  #      - /var/lib/docker/volumes:/var/lib/docker/volumes
  #      - /:/host

  dozzle:
    container_name: dozzle
    image: amir20/dozzle:latest
    restart: unless-stopped
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    ports:
      - "8180:8080"
    #    environment:
    #      - DOZZLE_AUTH_PROVIDER=simple
    #    secrets:
    #        - source: users
    #          target: /data/users.yml
    healthcheck:
      test: ["CMD", "/dozzle", "healthcheck"]
      interval: 3s
      timeout: 30s
      retries: 3
    networks:
      - frontend
      - backend
    depends_on:
      - watchtower
    labels:
      - "com.centurylinklabs.watchtower.enable=true"

  error-pages:
    container_name: error-pages
    image: tarampampam/error-pages:3.7
    restart: unless-stopped
    environment:
      - "TEMPLATE_NAME=app-down"
      - "SHOW_DETAILS=true"
      - TZ=Asia/Shanghai
    ports:
      - "8580:8080"
    depends_on:
      - watchtower
    networks:
      - frontend
      - backend
    labels:
      - "com.centurylinklabs.watchtower.enable=true"

#  registry:
#    container_name: registry
#    image: registry:3
#    restart: always
#    volumes:
#      - ${CONFIG_PATH}registry/registry-config.yml:/etc/docker/registry/config.yml
#    ports:
#      - "5000:5000"
#    environment:
#      - REGISTRY_HTTP_SECRET=lMNVjf20pKn86n8j7pUF1ijWtFDJ1BInPgEh8GjxyFA=
#      # 完全禁用OpenTelemetry追踪和指标
#      - OTEL_SDK_DISABLED=true
#      - OTEL_TRACES_EXPORTER=none
#      - OTEL_METRICS_EXPORTER=none
#      - OTEL_LOGS_EXPORTER=none
#      # 设置日志级别为info，避免debug日志
#      - REGISTRY_LOG_LEVEL=info
#    healthcheck:
#      test:
#        [
#          "CMD",
#          "wget",
#          "--no-verbose",
#          "--tries=1",
#          "--spider",
#          "http://localhost:5000/v2/",
#        ]
#      interval: 30s
#      timeout: 10s
#      retries: 3
#      start_period: 40s
#    networks:
#      - backend
#      - frontend

  watchtower:
    container_name: watchtower
    image: containrrr/watchtower
    restart: always
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock"
    ports:
      - "8880:8080"
    environment:
      - WATCHTOWER_HTTP_API_METRICS=true
      - WATCHTOWER_HTTP_API_TOKEN="demo_token"
      - WATCHTOWER_CLEANUP=true
      - WATCHTOWER_POLL_INTERVAL=3600 # 1小时检查一次
      - TZ=Asia/Shanghai
    healthcheck:
      test: ["CMD", "/watchtower", "--health-check"]
      interval: 10m
      timeout: 30s
      retries: 3
      start_period: 60s
    networks:
      - frontend
      - backend

#  autoheal:
#    container_name: autoheal
#    image: willfarrell/autoheal:latest
#    restart: always
#    environment:
#      #      AUTOHEAL_CONTAINER_LABEL: autoheal-app
#      - AUTOHEAL_CONTAINER_LABEL=all
#    network_mode: none
#    volumes:
#      - /etc/localtime:/etc/localtime:ro
#      - /var/run/docker.sock:/var/run/docker.sock
#    networks:
#      - frontend
#      - backend

#secrets:
#  users:
#    file: users.yml
